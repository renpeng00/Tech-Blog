
参考资料
1. [极客时间 Linux性能优化实战](https://time.geekbang.org/column/article/69859) 
2. [协程切换](https://www.cnblogs.com/liang1101/p/7285955.html)

# CPU 上线文且切换

## 基本知识
CPU寄存器  
程序计数器：用来存储CPU正在执行的指令位置、或者即将执行的下一条指令的位置  

## CPU上下文切换

### 切换过程
先把前一个任务的CPU上下文（CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后跳转到程序计数器所指的新的位置，运行新任务

### 进程上下文切换
内核空间：具有最高权限，可以直接访问所有资源  
用户空间：只能方访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源  

系统调用个过程会发生2次CPU上下文切换  

进程上下文切换，是指从一个进程切换到另一个进程，而系统调用过程一直是用一个进程，所以系统调用过程称为特权模式切换，而不是上线文切换  

进程切换：在保存当前进程内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、栈等保存下来，加载下一个进程的内核态后，还需要刷新进程的虚拟内存和用户栈

#### 发生进程切换的时机
1. 时间片调度
2. 进程在系统资源不足（比如内存不足）时，要等待资源满足后才能运行，此时进程会挂起
3. 当进程通过sleep()等方法主动挂起时，也会重新调度
4. 当有优先级更高的进程运行时，当前进程会被挂起


### 线程上下文切换
线程与进程的区别：线程是调度的基本单位，进程是资源分配的基本单位。内核的调度，实际上的调度对象是线程；而进程只能给线程提供虚拟内存，全局变量等资源

### 中断上线文切换
为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。在打断其他进程时，就需要将进程当前的状态保存，在中断结束后，进程仍然可以从原来的状态恢复运行。中断上下文切换并不涉及进程进程的用户态。所以即使中断过程打断了一个正在处于用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源，中断上下文，其实只包括内核态中断服务程序执行所必须的状态，包括CPU寄存器、内核堆栈、硬件中断参数。对于CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文同时发生   

### 协程
协程（用户级线程）是对内核透明的，系统不知道协程的存在，是完全由用户自己的程序进行调度的。  
每个goruntine默认占用内存远比java、c的线程少。  
goruntine：2k  
线程：8MB  
线程切换需要涉及模式切换（从用户态切换到内核态）、16个寄存器、PC、SP...等寄存器刷新等，goruntine只需要切换3个寄存器 PC/SP/DX




